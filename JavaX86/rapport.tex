\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Projet x86 Assembleur}
\author{BADOUAL CHAUSSÉ GRIMAUD GUILLOT}
\date{Mai 2024}

\begin{document}

\maketitle

\section{Introduction}
Le langage assembleur est le langage informatique le plus proche de la machine.

Il utilise pour cela des bits qui représente des valeurs binaires. Ce langage permet d'effectuer la plupart des calculs arithmétique et logiques. Ces instructions sont représenté par des symboles bien plus lisible par l'humain.

Exemple : \emph{mov eax,15}.

Dans cette expression on peut voir, une instruction, un registre et une valeur. Un registre est un emplacement de mémoire qui dans notre cas vas stocké un ensemble de bits qui pour cette expression correspondras à la valeur binaire de 15 (00000 1111).

Ces registres peuvent intéragir entre eux, exemples, les expression aarithmétique ou logiques entre deux registres.

\section{Organisation de notre programme}
\subsection{ASM}
Nous avons créé une classe ASM qui vas reprendre l'ensemble des registres x86 initialise. Ceci nous permet donc de directement les manipuler sans devoir les créer. Ce sera cette classe qui sera utilisé dans la partie interpretation graphique pour ne pas avoir à rajouter la gestion de la création.


\subsection{Register}
La classe Register est la classe principale du programme. En effet c'est dans cette classe que l'on vas définir l'ensemble des variables pour la création et la gestion des Registre.

Il possède un nom.
Un bitset (une array de boolean sur lequel certaines fonctions sont déjà définies).
Un entier de début et de fin.
Une partie haute et une partie basse.

Il y a plusieurs constructeurs possible avec initialisation de valeur ou non.

\subsubsection{Addition}
Pour implémenter le calcul de l'addition je me suis basé sur l'algorithme standard de calcul de l'addition binaire sur le BitSet de Registres.

\begin{verbatim}
1| boolean retenue=false;
2| boolean signed = r1.getArrayOfBit().get(r1.fin - 1) && r2.getArrayOfBit().get(r2.fin - 1);
3|
4| for(int i=0;i<r1.arrayOfBit.size();i++){
5|    boolean a1 = r1.arrayOfBit.get(i);
6|    r1.arrayOfBit.set(i,r1.arrayOfBit.get(i) ^ r2.arrayOfBit.get(i) ^ retenue); //addition de chaque bit 1 à 1
7|    retenue = (a1 & retenue) | (r2.arrayOfBit.get(i) & retenue) | (a1 & r2.arrayOfBit.get(i)); //Retenue si au moins 2 bit à 1
8| }
\end{verbatim}

1 - Initialisation de la variable chargée de stocké la retenue

4 - Boucle qui vas itérer sur l'entiereté de l'ArrayOfBit du registres 1

5 - Récupération du bit avec comme index i (utile car modifié par la suite)

6 - Cette ligne calcul la valeur du bit i à l'aide de 2 xor effectué sur la retnue, r1 et r2. Cette ligne représente l'addition bninaire de ces 2 bits.

7 - Pour finir, cette ligne calcul la valeur de la retenue pour le prochain bit. La retenue est vrai si au moins 2 des 3 valeurs (la retenue actuelle et les 2 registres) sont vrais.

Le resultat sera stocké par la suite dans le premier registre passé en paramètre, exemple :
\begin{verbatim}
mov eax,20
mov ebx,15
add eax,ebx

eax = 35 ; ebx = 15
\end{verbatim}

Il exite aussi des fonctions sur les piles :
\begin{itemize}
    \item push : Rajoute le bitset lié à la valeur ou au registre passé en paramètre
    \item pop : Récupère le dernier bitset enregistré dans la pile
\end{itemize}
Et pour finir les expression logiques sont aussi disponibles sur ces registres :
\begin{itemize}
    \item And :
    \item Or :
    \item Not :
\end{itemize}
\subsection{ASMEditor}
En utilisant la librairie Java swing, nous avons implémenté un éditeur de text qui nous permet d'afficher en même temps
les registres utilisé lors de l'éxécutions d'un script. Cet éditeur utilise notre classe ASM et possède une coloration automatique
des registres, des valeurs et des instrcutions disponible pour une création de script simplifiée.


\end{document}
