\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Projet x86 Assembleur}
\author{BADOUAL CHAUSSÉ GRIMAUD GUILLOT}
\date{Mai 2024}

\begin{document}

\maketitle

\section{Introduction}
Le langage assembleur est le langage informatique le plus proche de la machine.

Il utilise pour cela des bits qui représente des valeurs binaires. Ce langage permet d'effectuer la plupart des calculs arithmétique et logiques. Ces instructions sont représenté par des symboles bien plus lisible par l'humain.

Exemple : \emph{mov eax,15}.

Dans cette expression on peut voir, une instruction, un registre et une valeur. Un registre est un emplacement de mémoire qui dans notre cas vas stocké un ensemble de bits qui pour cette expression correspondras à la valeur binaire de 15 (00000 1111).

Ces registres peuvent intéragir entre eux, exemples, les expression aarithmétique ou logiques entre deux registres.

\section{Organisation du projet}

\subsection{Outils}
Le langage utilisé est Java, pour le back-end et pour le front-end.
La partie visuelle est développée avec Java Swing.
Pour une meilleure gestion du projet, nous avons utilisé Git, ce qui nous permet de pouvoir développer chacun de notre côté nos fonctionnalités sans dépendre des autres.
\\
Nous avons utilisé IntelliJ Idea pour le développement, qui bénéficie de plusieurs plugins utiles pour une gestion plus agréable des différents aspects du projet.
Par exemple le plugin GitToolbox qui permets de gerer le repo Git sans utiliser de lignes de commandes et qui nous permets d'avoir un visuel en temps réel sur les différentes branches.
Le projet est un projet Maven.

\section{Organisation de notre programme}
\subsection{ASM}
Nous avons créé une classe ASM qui vas reprendre l'ensemble des registres x86 initialise. Ceci nous permet donc de directement les manipuler sans devoir les créer. Ce sera cette classe qui sera utilisé dans la partie interprétation graphique pour ne pas avoir à rajouter la gestion de la création.
Cette classe est donc composée de 16 BitSets de 128bits. À chacun de ces BitSets seront attribués un registre de chaque taille de la classe Register que nous verront plus bas. De ce fait, les registes de 16 bits (ax par exemple) définieront la partie basse des registres de 32 bits (dans le cas d'eax, sa partie basse sera ax).
La classe ASM représentera donc l'ensemble des registres utilisables, afin d'être fonctionnel, et utilisable avec l'interface graphique qui utilise des chaines de caractères, elle implémente une fonction "parsing(String)" qui retournera le registre dont le nom est donné.
Cette fonction sera utilisée dans la plupart des fonctions de la classe qui utiliseront un ou plusieurs registres à partir de leur noms. Par la suite, cette classe implémentera le lien entre les fonctions de l'interface graphique et celle de la classe Register que nous verront plus bas.

\subsection{Register}
La classe Register est la classe principale du programme. En effet c'est dans cette classe que l'on vas définir l'ensemble des variables pour la création et la gestion des Registre.

Il possède un nom qui sert essentiellement à les identifier.
Un bitset.
Un entier de début et de fin.
Une partie haute et une partie basse.

Le bitset des registres correspond à un tableau de Bits. De manière technqiue, il s'agit d'un Array de booléen sur lequel certains calculs sont déjà implémentés.

Il y a plusieurs constructeurs possible avec initialisation de valeur ou non.

\subsection{ASMEditor}

Nous avons décidé d'implémenter une interface graphique pour avoir une expérience plus agréable et dynamique sur la visualisation des résultats et sur
l'écriture des instructions.
Nous avons pour cela utilisé la librairie Java Swing, ce qui nous paraissait la plus adaptée pour ce type de visuel.
\\
\\
\includegraphics[width=0.5\textwidth]{img/interface_graphique.png}

L'interface graphique est divisée en deux parties : l'éditeur et les résultats.
Il y a premièrement l'éditeur de texte,qui permet d'insérer les instructions.
La coloration du texte concerne les registres, les mots-clés des instructions, ainsi que les nombres.
Nous avons aussi fait en sorte qu'il soit possible de mettre des commentaires colorés en gris, qui sont caractérisés par un point-virgule en début de ligne.
Ainsi, l'éditeur ne traitera pas ce qui suit le point-virgule.
\\
Ensuite, nous avons le tableau de registres, qui affiche pour chaque registres traités par les instructions son nom, sa valeur binaire, hexadécimale et décimale.
Ce tableau est mis à jour à chaque fois que le bouton "Run" est lancé.
Ce bouton traite les instructions de l'éditeur ligne par ligne.
Quand on clique sur "Run", le contenu de l'éditeur est stocké dans un fichier JSON.
Une méthode va interpréter ce fichier ligne par ligne pour reconnaitre les mots-clés à traiter.
Ensuite, chaque registre qui est modifié ou appelé va etre stocké dans un autre JSON, et ce fichier sera lu pour afficher ces registres dans le tableau de l'interface graphique.
Nous affichons aussi les Flags en bas du tableau.

\subsection{Stack}

La classe AsmStack est une classe singleton représentant la pile du coprocesseur arithmétique. Elle implémente les opérations push et pop et
une taille maximale en bit peut être fixé pour représenter les limitations d'un vrai coprocesseur arithmétique. Par défaut, cette limite est de 64 kb.

\subsection{Flags}

La classe Flag est une classe registre particulière qui représente 5 drapeaux,le "Carry Flag", le "Parity Flag", le "Zero Flag", le "Sign Flag", et le "Overflow Flag".

\section{Operations arithmetiques}
\subsection{mov}
mov permet l'enregistrement d'une valeur entière dans un registre.
\\
\\
\includegraphics[width=0.5\textwidth]{img/mov.png}

\newpage
\subsubsection{Addition}
Pour implémenter le calcul de l'addition je me suis basé sur l'algorithme standard de calcul de l'addition binaire sur le BitSet de Registres.

\begin{verbatim}
1| boolean retenue=false;
2| boolean signed = r1.getArrayOfBit().get(r1.fin - 1) && r2.getArrayOfBit().get(r2.fin - 1);
3|
4| for(int i=0;i<r1.arrayOfBit.size();i++){
5|    boolean a1 = r1.arrayOfBit.get(i);
6|    r1.arrayOfBit.set(i,r1.arrayOfBit.get(i) ^ r2.arrayOfBit.get(i) ^ retenue); //addition de chaque bit 1 à 1
7|    retenue = (a1 & retenue) | (r2.arrayOfBit.get(i) & retenue) | (a1 & r2.arrayOfBit.get(i)); //Retenue si au moins 2 bit à 1
8| }
\end{verbatim}

1 - Initialisation de la variable chargée de stocké la retenue.

4 - Boucle qui vas itérer sur l'entiereté de l'ArrayOfBit du registres 1.

5 - Récupération du bit avec comme index i (utile car modifié par la suite).

6 - Cette ligne calcul la valeur du bit i à l'aide de 2 xor (ou exclusif) effectué sur la retenue, r1 et r2. Cette ligne représente l'addition bninaire de ces 2 bits.

7 - Pour finir, cette ligne calcul la valeur de la retenue pour le prochain bit. La retenue est vrai si au moins 2 des 3 valeurs (la retenue actuelle et les 2 registres) sont vrais.

Le resultat sera stocké par la suite dans le premier registre passé en paramètre, exemple :
\begin{verbatim}
mov eax,20
mov ebx,15
add eax,ebx

eax = 35 ; ebx = 15
\end{verbatim}

\newpage
\subsection{shl}
shl produit un décalage à gauche d'un registre selon la valeur souhaitée.
\\
\\
\includegraphics[width=0.5\textwidth]{img/shl.png}

\subsection{shr}
shr produit un décalge à droite d'un registre selon la valeur souhaitée.
\\
\\
\includegraphics[width=0.5\textwidth]{img/shr.png}
\newpage
\subsection{mul}
La multiplication s'effectue en faisant la somme de la valeur du multiplicande par les valeurs des bits du multiplicateur avec un décallage à gauche
\begin{verbatim}
1| for (int i = operande.debut; i < operande.fin; i++) {
2|          if (operande.getArrayOfBit().get(i)) {
3|              boolean retenue = false;
4|              for(int j=0;j<result.size();j++){
5|                  boolean a1 = result.get(j);
6|                  result.set(j,result.get(j) ^ r2.arrayOfBit.get(j) ^ retenue); //addition de chaque bit 1 à 1
7|                  retenue = (a1 & retenue) | (r2.arrayOfBit.get(j) & retenue) | (a1 & r2.arrayOfBit.get(j)); //Retenue si au moins 2 bit à 1
8|              }
9|          }
10|         r2.shl(1);
11|     }
\end{verbatim}
1 | Pour chaque valeur du multiplicande ("operande")\\
2 | s'il est égal à 1\\
3-7 | on l'additionne au résultat,\\
10 | Enfin on décalle de 1 vers la gauche\\

\subsection{div}
La division s'effectue en suivant un algorithme binaire proche de la technique de la division Egyptienne.
\\
\\
Le principe est de construire à l'envers un tableau de multiplications égytien en construisant un tableau de puissances de 2 et de leur produit par le diviseur. Afin d'optimiser de la mémoire et du temps de calcul, la méthode binaire utilise une approche dichotomique de cette algorithme. La méthode originale "dite naïve" nécessite de construire la suite du tableau en additionnant les résulats précédents afin de trouver le quotien le plus
proche possible.
\\
\\
La méthode dichotomique a une approche légèrement différente. On recherche d'abord la première puissance de 2 qui, multiplié par le quotient, sera supérieure au dividende.
\\
On considère donc la suite géométrique $2^{n}$.
\\
Tant que $2^{n} * diviseur \leq dividende$ on incrémente $n$ de 1. On arrête le calcul lorsque l'on trouve N, le plus petit entier tel que :
\\
$2^{N} * diviseur > dividende$.
\\
\\
Le nombre d'étapes pour arriver à ce résultat de l'ordre de $log_{2}(\frac{dividende}{diviseur})$. De plus, chacune de ces étapes ne nécessite qu'une multiplication ainsi qu'un décalage à gauche et une comparaison.
\\
\\
Pour la deuxième partie de l'algorithme, on construit deux suites de minorants ($\alpha_{n}$) et de majorants ($\beta_{n}$) du quotient.
\\
On a donc: $\alpha_{0} = 2^{N-1}$ et $\beta_{0} = 2^{N}$.
\\
Puis, on calcule par récurrence :
\\
$\alpha_{n+1} = \frac{\alpha_{n} + \beta_{n}}{2}$ et $\beta_{n+1} = \beta_{n}$ si $\frac{\alpha_{n} + \beta_{n}}{2} * diviseur < dividende$
\\
$\beta_{n+1} = \frac{\alpha_{n} + \beta_{n}}{2}$ et $\alpha_{n+1} = \alpha_{n}$ dans le cas contraire.
\\
En cas d'égalité, le quotient est donc $\frac{\alpha_{n} + \beta_{n}}{2}$ et on peut sortir de la boucle de calcul.
\\
S'il n'y a jamais égalité, on trouve le quotient au bout de maximum N - 1 itérations.
\\
Une autre propriété de ce calcul est que les deux suites sont toujours séparées de $2^{N - 1 - n}$ ce qui permet de montrer que les suites sont toujours définies dans l'intervalle et que dans le cas
d'itérations maximales, $\alpha_{N - 1}$ est le plus grand minorant du quotient, c'est à dire, le quotient.
\\
\\
Le nombre maximum d'étapes pour ce calcul est de $\log_2{\frac{dividende}{diviseur}}$ qui chacune ne nécessite que des additions, multiplication, décalages et comparaisons.
\\
En concaténant les 2 étapes l'algorithme est très efficace avec une complexité qui grandit en fonction de $\frac{dividende}{diviseur}$ et donc de manière linéaire avec le $dividende$. Cette méthode est donc très efficace.
\\
\\
Enfin, le reste se calcul en effectuant une simple soustraction : $reste = dividende - quotient * diviseur$

\end{document}
